{"id":922,"date":"2022-11-26T00:26:42","date_gmt":"2022-11-25T18:56:42","guid":{"rendered":"https:\/\/vinayaroratech.com\/?p=922"},"modified":"2022-11-26T00:26:43","modified_gmt":"2022-11-25T18:56:43","slug":"how-to-load-net-configuration-from-aws-secrets-manager","status":"publish","type":"post","link":"https:\/\/vinayaroratech.com\/dotnet\/how-to-load-net-configuration-from-aws-secrets-manager\/","title":{"rendered":"How to load .NET configuration from AWS Secrets Manager"},"content":{"rendered":"\n<p>Every application has secrets \u2013 database credentials, API keys used to call external services, or private encryption keys needed to secure data. In this blog post, I will show you how you can load and use secrets using .NET\u2019s configuration system and\u00a0<a href=\"https:\/\/aws.amazon.com\/secrets-manager\/\">AWS Secrets Manager (Secrets Manager)<\/a>.<\/p>\n\n\n\n<p>Keeping your sensitive data outside of your code is crucial, but reducing the risk of compromise is not always a simple task. Many companies find themselves inventing complex and difficult-to-implement techniques, which result in a less streamlined development experience. This might lead developers to find simpler, less secure solutions for storing the application\u2019s sensitive data, such as using hard-coded strings in the application\u2019s code or configuration files. This may lead to a security breach when code that contains sensitive data is then saved in the company\u2019s source control, where multiple parties can access it without proper auditing or other security safeguards. In addition, an organization needs to keep track of multiple versions of the same secret and different values depending on the deployed environment (such as dev, staging, or production). This can become difficult when those secrets are tightly coupled with the deployed code.<\/p>\n\n\n\n<p>Secrets Manager helps you protect secrets needed to access your applications, services, and IT resources. It enables you to easily rotate, manage, and retrieve secrets used by your application, eliminating the need to hard-code sensitive information in plain text. You can use the Secrets Manager client to retrieve secrets using AWS SDK for .NET. However, this would require code changes and add to the complexity of your code, as you need to invoke the client whenever you need to read data stored in Secrets Manager. Instead, you can use the&nbsp;<a href=\"https:\/\/docs.microsoft.com\/en-us\/aspnet\/core\/fundamentals\/configuration\/?view=aspnetcore-6.0\">.NET configuration system<\/a>&nbsp;\u2013 an extensible API used to read and manage application secrets. This lets developers use a familiar API to access secrets in secure storage and reduce complexity by using a single code path for all environments. Additionally, the provider lets existing applications move to Secrets Manager without making any code changes.<\/p>\n\n\n\n<p>In this blog post, I will show you how to create a custom configuration provider that loads sensitive data from Secrets Manager and makes those secrets available to your application.<\/p>\n\n\n\n<h1>Walktrough<\/h1>\n\n\n\n<p>To load values from Secrets Manager to your .NET configuration, you will need to complete the following steps:<\/p>\n\n\n\n<ul><li>Create a custom configuration provider<\/li><li>Create a configuration source to initialize the new provider<\/li><li>Create a new class to pass the secret\u2019s data to your code<\/li><li>Update your code to use the new configuration source<\/li><li><em>Optional: enable secrets reloading<\/em><\/li><\/ul>\n\n\n\n<h1>Prerequisites<\/h1>\n\n\n\n<p>This example will use credentials needed to connect to a 3rd-party API. The credentials will include an API key, user ID, and password \u2014 all stored in Secrets Manager.<\/p>\n\n\n\n<p>Create a secret to use in your application<br>First, you\u2019ll need to add a new secret to load from your code.<\/p>\n\n\n\n<ol><li>Log in to the&nbsp;<a href=\"https:\/\/console.aws.amazon.com\/secretsmanager\">Secrets Manager console<\/a><\/li><li>Click on the Store a new secret to create your new secret value.<\/li><li>Choose Other type of secret and add the following key\/value pairs:<code>{ \"ApiKey\": \"key1\", \"UserId\": \"User1\", \"Password\": \"12345\", }<\/code>JSON<img loading=\"lazy\" src=\"https:\/\/d2908q01vomqb2.cloudfront.net\/8effee409c625e1a2d8f5033631840e6ce1dcb64\/2022\/09\/18\/Choose-secret-type.png\" alt=\"AWS Secrets Manager - Choose Secret Type\" width=\"977\" height=\"881\"><\/li><li>Choose&nbsp;<strong>Next<\/strong><\/li><li>Fill the secret\u2019s name, description, add tags and then choose&nbsp;<strong>Next<\/strong><\/li><li>On the next screen, choose&nbsp;<strong>Next<\/strong>&nbsp;on the Secret rotation page (automatic rotation disabled)<\/li><li>On the last screen, choose&nbsp;<strong>Store<\/strong>&nbsp;once you\u2019re done reviewing your changes.<\/li><\/ol>\n\n\n\n<h2>Create an ASP.NET Core Web API project<\/h2>\n\n\n\n<p>Although the .NET configuration system can be used by different project types and different versions of .NET, I am using the .NET 6 ASP.NET Core Web API project template (using Visual Studio 2022 or later).<\/p>\n\n\n\n<ol><li>Create a new project of type ASP.NET Core Web API<\/li><li>Fill your project name and choose&nbsp;<strong>Next<\/strong><\/li><li>On the next screen, make sure .NET 6.0 is selected, and choose&nbsp;<strong>Create<\/strong><\/li><\/ol>\n\n\n\n<h1>Step 1: Create a custom configuration provider<\/h1>\n\n\n\n<ol><li>Use NuGet to add\u00a0<em>AWS.SecretsManager<\/em>\u00a0as a dependency in your project.<\/li><li>Create a new class named\u00a0<code>AmazonSecretsManagerConfigurationProvider<\/code>\u00a0that inherits from the\u00a0<code>ConfigurationProvider<\/code>\u00a0abstract class. The class constructor will receive two string parameters,\u00a0<em>region<\/em>\u00a0and\u00a0<em>secretName<\/em>, and store them as fields in the class.<\/li><li>Override the\u00a0<em>Load<\/em>\u00a0method and add code to retrieve your secret from Secrets Manager as JSON, then deserialize the result as a\u00a0<code>Dictionary&lt;string, string><\/code>. Store the result in\u00a0<em>Data<\/em>\u00a0property (inherited from ConfigurationProvider):<\/li><\/ol>\n\n\n\n<pre class=\"wp-block-code\"><code>public class AmazonSecretsManagerConfigurationProvider : ConfigurationProvider\r\n{\r\n    private readonly string _region;\r\n    private readonly string _secretName;\r\n\r\n    public AmazonSecretsManagerConfigurationProvider(string region, string secretName, PeriodicWatcher watcher)\r\n    {\r\n        _region = region;\r\n        _secretName = secretName;\r\n        ChangeToken.OnChange(() => watcher.Watch(), Load);\r\n    }\r\n\r\n    public override void Load()\r\n    {\r\n        string secret = GetSecret();\r\n\r\n        Data = JsonSerializer.Deserialize&lt;Dictionary&lt;string, string>>(secret);\r\n    }\r\n\r\n    private string GetSecret()\r\n    {\r\n        var request = new GetSecretValueRequest\r\n        {\r\n            SecretId = _secretName,\r\n            VersionStage = \"AWSCURRENT\" \/\/ VersionStage defaults to AWSCURRENT if unspecified.\r\n        };\r\n\r\n        using var client = new AmazonSecretsManagerClient(RegionEndpoint.GetBySystemName(_region));\r\n        var response = client.GetSecretValueAsync(request).Result;\r\n        if (response.SecretString != null)\r\n        {\r\n            return response.SecretString;\r\n        }\r\n        else\r\n        {\r\n            var memoryStream = response.SecretBinary;\r\n            var reader = new StreamReader(memoryStream);\r\n            string str = reader.ReadToEnd();\r\n            return Encoding.UTF8.GetString(Convert.FromBase64String(str));\r\n        }\r\n    }\r\n}<\/code><\/pre>\n\n\n\n<h1>Step 2: Create a configuration source to initialize the new provider<\/h1>\n\n\n\n<p>Create a class that implements&nbsp;<code>IConfigurationSource<\/code>&nbsp;and creates a new instance of&nbsp;<code>AmazonSecretsManagerConfigurationProvider<\/code>:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class AmazonSecretsManagerConfigurationSource : IConfigurationSource\n{\n    private readonly string _region;\n    private readonly string _secretName;\n\n    public AmazonSecretsManagerConfigurationSource(string region, string secretName)\n    {\n        _region = region;\n        _secretName = secretName;\n    }\n\n    public IConfigurationProvider Build(IConfigurationBuilder builder)\n    {\n        return new AmazonSecretsManagerConfigurationProvider(_region, _secretName);\n    }\n}\n<\/code><\/pre>\n\n\n\n<h1>Step 3: Create a new class to pass the secret\u2019s data to your code<\/h1>\n\n\n\n<p>Create a new class that has properties with the same names as the secret\u2019s keys:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class MyApiCredentials\n{\n    public string ApiKey { get; set; }\n    public string UserId { get; set; }\n    public string Password { get;set; }\n}\n<\/code><\/pre>\n\n\n\n<h1>Step 4: Update your code to use the new configuration source<\/h1>\n\n\n\n<p>In this example, I\u2019m using the Visual Studio 2022 .NET project templates. In the new templates, the service\u2019s configuration is in the&nbsp;<em>Program.cs<\/em>&nbsp;file. Older IDEs (such as Visual Studio 2019 or prior) have similar code in the&nbsp;<em>Startup.cs<\/em>&nbsp;file.<\/p>\n\n\n\n<ul><li>Create a new static class with an extension method to initialize the new configuration source and add it to the configuration builder:<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code>public static class Startup\r\n{\r\n    public static void AddAmazonSecretsManager(\r\n        this IConfigurationBuilder configurationBuilder,\r\n        string region,\r\n        string secretName)\r\n    {\r\n        var configurationSource = new AmazonSecretsManagerConfigurationSource(region, secretName);\r\n\r\n        configurationBuilder.Add(configurationSource);\r\n    }\r\n\r\n    public static IServiceCollection AddMyApiCredentials(this IServiceCollection services, IConfiguration configuration)\r\n    {\r\n        return services.Configure&lt;MyApiCredentials>(configuration);\r\n    }\r\n}<\/code><\/pre>\n\n\n\n<ul><li>Add the new configuration provider to the existing list of configuration providers:<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code>internal static class Startup\r\n{\r\n    internal static ConfigureHostBuilder AddConfigurations(this ConfigureHostBuilder host)\r\n    {\r\n        host.ConfigureAppConfiguration((context, config) =>\r\n        {\r            \r\r\n            var configRoot = config.Build();\r\n            string region = configRoot&#91;\"AWSSecertManager:Region\"];\r\n            string secretName = configRoot&#91;\"AWSSecertManager:SecretName\"];\r\n            config.AddAmazonSecretsManager(region, secretName);\r\n        });\r\n        return host;\r\n    }\r\n}<\/code><\/pre>\n\n\n\n<p>Now, use the built-in configuration IOption interface to inject the credentials into your application:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>private readonly MyApiCredentials _myApiCredentials;\r\n\r\npublic MyService(IOptions&lt;MyApiCredentials> options)\r\n{\r\n    _myApiCredentials = options.Value;\r\n}<\/code><\/pre>\n\n\n\n<h1>Step 5: Reloading secrets<\/h1>\n\n\n\n<p>If your application requires configuration updates without restarting \u2013 you will need to add functionality to your configuration provider to refresh the configuration data.<\/p>\n\n\n\n<ul><li>Create a new class that will hold the logic needed to refresh your configuration values.This class must have a method\/property that returns\u00a0<code>IChangeToken<\/code>:<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code>public class PeriodicWatcher : IDisposable\r\n{\r\n    private readonly TimeSpan _refreshInterval;\r\n    private IChangeToken _changeToken;\r\n    private readonly Timer _timer;\r\n    private CancellationTokenSource _cancellationTokenSource;\r\n\r\n    public PeriodicWatcher(TimeSpan refreshInterval)\r\n    {\r\n        _refreshInterval = refreshInterval;\r\n        _timer = new Timer(OnChange, null, TimeSpan.Zero, _refreshInterval);\r\n    }\r\n\r\n    private void OnChange(object? state)\r\n    {\r\n        _cancellationTokenSource?.Cancel();\r\n    }\r\n\r\n    public IChangeToken Watch()\r\n    {\r\n        _cancellationTokenSource = new CancellationTokenSource();\r\n        _changeToken = new CancellationChangeToken(_cancellationTokenSource.Token);\r\n\r\n        return _changeToken;\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _timer?.Dispose();\r\n        _cancellationTokenSource?.Dispose();\r\n    }\r\n}\r\n<\/code><\/pre>\n\n\n\n<ul><li>Here I\u2019m using the built-in\u00a0<code>CancellationChangeToken<\/code>\u00a0class to create a change token from\u00a0<code>CancellationTokenSource<\/code>.<\/li><li>Pass an instance of that class to the configuration provider and call\u00a0<code>ChangeToken.OnChange<\/code>\u00a0to tie the change token to a method that will be called on each change \u2013 in this case Load:<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code> public AmazonSecretsManagerConfigurationProvider(string region, string secretName, PeriodicWatcher watcher)\r\n    {\r\n        _region = region;\r\n        _secretName = secretName;\r\n        ChangeToken.OnChange(() => watcher.Watch(), Load);\r\n    }<\/code><\/pre>\n\n\n\n<ul><li>Update your code to use\u00a0<em>IOptionsSnapshot\u00a0<\/em>instead of\u00a0<em>IOption<\/em>.\u00a0<code>IOption&lt;T><\/code>\u00a0caches the configuration read from Data once for the entire application lifecycle, but\u00a0<code>IOptionsSnapshot&lt;T><\/code>\u00a0reads Data on each HTTP request, making sure that the provider gets the latest configuration values:<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code>private readonly string _myApiCredentials;\r\n\r\npublic MyService(IOptionsSnapshot&lt;MyApiCredentials> options)\r\n{\r\n    _myApiCredentials = options.Value;\r\n}\r\n<\/code><\/pre>\n\n\n\n<h1>Conclusion<\/h1>\n\n\n\n<p>Every application has sensitive data it needs to store in a secure location. Keeping sensitive data in your application code can cause a security breach. On the other hand, you do not want to slow down developers by adding hard-to-follow steps to run and debug your application.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Every application has secrets \u2013 database credentials, API keys used to call external services, or private encryption keys needed to secure data. In this blog post, I will show you how you can load and use secrets using .NET\u2019s configuration system and\u00a0AWS Secrets Manager (Secrets Manager). Keeping your sensitive data outside of your code is &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"https:\/\/vinayaroratech.com\/dotnet\/how-to-load-net-configuration-from-aws-secrets-manager\/\"> <span class=\"screen-reader-text\">How to load .NET configuration from AWS Secrets Manager<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[1,5,79,13],"tags":[86,76,59,87,85],"_links":{"self":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/922"}],"collection":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/comments?post=922"}],"version-history":[{"count":1,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/922\/revisions"}],"predecessor-version":[{"id":923,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/922\/revisions\/923"}],"wp:attachment":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/media?parent=922"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/categories?post=922"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/tags?post=922"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}