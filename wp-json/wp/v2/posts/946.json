{"id":946,"date":"2023-01-10T12:49:15","date_gmt":"2023-01-10T07:19:15","guid":{"rendered":"https:\/\/vinayaroratech.com\/?p=946"},"modified":"2023-01-10T22:27:48","modified_gmt":"2023-01-10T16:57:48","slug":"getting-started-with-opentelemetry-and-distributed-tracing-in-net-core","status":"publish","type":"post","link":"https:\/\/vinayaroratech.com\/dotnet\/getting-started-with-opentelemetry-and-distributed-tracing-in-net-core\/","title":{"rendered":"Getting started with OpenTelemetry and distributed tracing in .NET Core"},"content":{"rendered":"\n<blockquote class=\"wp-block-quote\"><p><strong>Just show me the code<\/strong><br>As always if you don\u2019t care about the post I have upload the source code on my&nbsp;<a href=\"https:\/\/github.com\/vinaykarora\/opentelemetry-tracing-demo\">Github<\/a><\/p><\/blockquote>\n\n\n\n<p>A few months ago the first stable version of the OpenTelemetry client for dotnet was released and since then I have wanted to write a little bit about it.<\/p>\n\n\n\n<p>OpenTelemetry is a set of APIs, SDKs, tooling and integrations that are designed for the creation and management of telemetry data such as traces, metrics, and logs. Today I\u2019m going to focus on tracing.<br>From my standpoint, there are at least&nbsp;<strong>four main concepts<\/strong>&nbsp;about tracing and OpenTelemetry that you need to know.<\/p>\n\n\n\n<h2 id=\"span-and-activities\"><strong>Span and activities<\/strong><\/h2>\n\n\n\n<p>A span is the building block that forms a trace, it has a unique identifier and represents a piece of the workflow in the distributed system.<br>Multiple spans are pieced together to create a trace. Traces are often viewed as a \u201ctree\u201d of spans that reflects the time that each span started and completed.<\/p>\n\n\n\n<p>In dotnet a Span is represented by an&nbsp;<strong>Activity<\/strong>.<\/p>\n\n\n\n<p>The OpenTelemetry client for dotnet is reusing the existing Activity and associated classes to represent the OpenTelemetry Span.<br>This means that users can instrument their applications\/libraries to emit OpenTelemetry compatible traces by using just the .NET Runtime.<\/p>\n\n\n\n<p>To create a Span in .NET we must first create a new activity:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>private static readonly ActivitySource Activity = new(nameof(RabbitRepository));\n<\/code><\/pre>\n\n\n\n<p>And then call&nbsp;<em>\u201cStartActivity\u201d<\/em>&nbsp;to begin recording, everything that happens inside the using block will be recorded into that Span.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>using (var activity = Activity.StartActivity(\"Process Message\", ActivityKind.Consumer, parentContext.ActivityContext)){}\n<\/code><\/pre>\n\n\n\n<h2 id=\"propagators\"><strong>Propagators<\/strong><\/h2>\n\n\n\n<p>A propagator allows us to extract and inject context across process boundaries.<\/p>\n\n\n\n<p>This is typically required if you are not using any of the .NET communication libraries which has instrumentations already available which does the propagation (eg: HttpClient).<br>In such cases, context extraction and propagation is the responsibility of the library itself.<\/p>\n\n\n\n<p>To create a propagator in .NET we must first create a TextMapPropagator<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>private static readonly TextMapPropagator Propagator = new TraceContextPropagator();\n<\/code><\/pre>\n\n\n\n<p>Then use the Inject and Extract methods for inter-process trace propagation.<\/p>\n\n\n\n<p>The&nbsp;<em>\u201cInject\u201d<\/em>&nbsp;method injects the Activity into a carrier. For example, into the headers of an HTTP request.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Propagator.Inject(new PropagationContext(activity.Context, Baggage.Current), props, InjectContextIntoHeader);\n<\/code><\/pre>\n\n\n\n<p>And the&nbsp;<em>\u201cExtract\u201d<\/em>&nbsp;method extracts the value from an incoming request. For example, from the headers of an HTTP request.<\/p>\n\n\n\n<p>If a value can not be parsed from the carrier, for a cross-cutting concern, the implementation should not throw an exception and should not store a new value in the Context, in order to preserve any previously existing valid value.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code> var parentContext = Propagator.Extract(default, ea.BasicProperties, ExtractTraceContextFromBasicProperties);\n<\/code><\/pre>\n\n\n\n<h2 id=\"exporters\"><strong>Exporters<\/strong><\/h2>\n\n\n\n<p>Let\u2019s be honest emiting traces is kind of pointless if you don\u2019t have a backend capable of aggregating the traces and displaying those traces in a friendly manner.<\/p>\n\n\n\n<p>An exporter is how data gets sent to those different back-ends.<\/p>\n\n\n\n<p>Generally, an exporter translates the internal format into another defined format.<\/p>\n\n\n\n<p>These are the most well-known available trace exporters:<\/p>\n\n\n\n<ul><li>Jaeger<\/li><li>OTLP gRPC<\/li><li>OTLP HTTP<\/li><li>Zipkin<\/li><\/ul>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>In this post I\u2019m going to use&nbsp;<strong>Jaeger<\/strong>.<\/p><\/blockquote>\n\n\n\n<h2 id=\"attributes\"><strong>Attributes<\/strong><\/h2>\n\n\n\n<p>Attributes are key:value pairs that provide additional information to a trace.<\/p>\n\n\n\n<p>In .NET those are called Tags. We can add an attribute into an Activity like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  activity?.SetTag(\"messaging.system\", \"rabbitmq\");\n  activity?.SetTag(\"messaging.destination_kind\", \"queue\");\n  activity?.SetTag(\"messaging.rabbitmq.queue\", \"sample\");\n<\/code><\/pre>\n\n\n\n<hr class=\"wp-block-separator\"\/>\n\n\n\n<p>I\u2019m going to stop talking about OpenTelemetry theory because I could end up writing and entire post about it.<br>And to be honest I would end up paraphrasing of the official docs, so instead of that I\u2019m going to point you towards the official documentation:&nbsp;<a href=\"https:\/\/opentelemetry.io\/docs\/concepts\/\">https:\/\/opentelemetry.io\/docs\/concepts\/<\/a><\/p>\n\n\n\n<p>After talking a little bit about OpenTelemetry let me refocus on the&nbsp;<strong>real<\/strong>&nbsp;purpose of this post.<\/p>\n\n\n\n<h3 id=\"in-this-post-i-want-to-show-you-a-practical-example-about-how-you-can-start-using-opentelemetry-when-you-have-a-series-of-net-services-that-communicate-amongst-them\">In this post I want to show you a practical example about how you can start using OpenTelemetry when you have a series of .NET services that communicate amongst them.<\/h3>\n\n\n\n<h1 id=\"example\">Example<\/h1>\n\n\n\n<p>I have built 4 apps beforehand, these apps are not doing any business logic operations because that\u2019s not the goal here.<br>The important part is that all the apps are talking among them and also using other external services like Redis, MSSQL or Rabbit.<\/p>\n\n\n\n<p>Here\u2019s the diagram:<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-components-diagram.png\" alt=\"otel-diagram\"\/><\/figure>\n\n\n\n<ul><li><strong>App1.WebApi<\/strong>&nbsp;is a&nbsp;<strong>NET6 Web API<\/strong>&nbsp;with 2 endpoints.<ul><li>The&nbsp;<strong>\/http<\/strong>&nbsp;endpoint makes an HTTP request to the App2&nbsp;<em>&#8220;\/dummy&#8221;<\/em>&nbsp;endpoint.<\/li><li>The&nbsp;<strong>\/publish-message<\/strong>&nbsp;endpoint queues a message into a Rabbit queue named&nbsp;<em>\u201csample\u201d<\/em>.<\/li><\/ul><\/li><li><strong>App2.RabbitConsumer.Console<\/strong>&nbsp;is a&nbsp;<strong>NET6 console<\/strong>&nbsp;application.<ul><li>Dequeues messages from the Rabbit&nbsp;<em>\u201csample\u201d<\/em>&nbsp;queue and makes a HTTP request to the&nbsp;<strong>App3<\/strong>&nbsp;<em>&#8220;\/sql-to-event&#8221;<\/em>&nbsp;endpoint with the content of the message.<\/li><\/ul><\/li><li><strong>App3.WebApi<\/strong>&nbsp;is a&nbsp;<strong>NET6 Web API<\/strong>&nbsp;with 2 endpoints<ul><li>The&nbsp;<strong>\/dummy<\/strong>&nbsp;endpoint returns a fixed&nbsp;<em>\u201cOk\u201d<\/em>&nbsp;response.<\/li><li>The&nbsp;<strong>\/sql-to-event<\/strong>&nbsp;endpoint receives a message via HTTP POST, stores it in a MSSQL Server and afterwards publishes the message as an event into a RabbitMq queue named&nbsp;<em>\u201csample_2\u201d<\/em>.<\/li><\/ul><\/li><li><strong>App4.RabbitConsumer.HostedService<\/strong>&nbsp;is a&nbsp;<strong>NET6 Worker Service<\/strong>.<ul><li>A Hosted Service reads the messages from the Rabbitmq&nbsp;<em>\u201csample_2\u201d<\/em>&nbsp;queue and stores it into a Redis cache database.<\/li><\/ul><\/li><\/ul>\n\n\n\n<p>Those apps are not using OpenTelemetry right now, so in the next sections we\u2019re going to do a step-by-step guide about how to setup and use the OpenTelemetry client.<\/p>\n\n\n\n<h1 id=\"opentelemetry-net-client\">OpenTelemetry .NET Client<\/h1>\n\n\n\n<p>To get started with OpenTelemetry we\u2019re going to need the following packages.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;PackageReference Include=\"OpenTelemetry\" Version=\"1.2.0-rc1\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Exporter.Jaeger\" Version=\"1.2.0-rc1\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Extensions.Hosting\" Version=\"1.0.0-rc8\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Instrumentation.AspNetCore\" Version=\"1.0.0-rc8\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Instrumentation.Http\" Version=\"1.0.0-rc8\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Instrumentation.SqlClient\" Version=\"1.0.0-rc8\" \/&gt;\n&lt;PackageReference Include=\"OpenTelemetry.Instrumentation.StackExchangeRedis\" Version=\"1.0.0-rc8\" \/&gt;\n<\/code><\/pre>\n\n\n\n<ul><li>The&nbsp;<em><strong>OpenTelemetry<\/strong><\/em>&nbsp;package is the core library.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Exporter.Jaeger<\/strong><\/em>&nbsp;package allows us to export the traces to Jaeger.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Extensions.Hosting<\/strong><\/em>&nbsp;package contains some extensions that allows us to add the dependencies into the DI container and configure the HostBuilder.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Instrumentation.<\/strong>*<\/em>&nbsp;packages are instrumentation libraries. These packages are instrumenting common libraries\/functionalities\/classes so we don\u2019t have to do all the heavy lifting by ourselves. In our example we\u2019re using the following ones:<ul><li>The&nbsp;<em><strong>OpenTelemetry.Instrumentation.AspNetCore<\/strong><\/em>&nbsp;instruments&nbsp;<em>ASP.NET Core<\/em>&nbsp;and collects telemetry about incoming web requests. This instrumentation also collects incoming gRPC requests using&nbsp;<em>Grpc.AspNetCore<\/em>.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Instrumentation.Http<\/strong><\/em>&nbsp;instruments the&nbsp;<em>System.Net.Http.HttpClient<\/em>&nbsp;and&nbsp;<em>System.Net.HttpWebRequest<\/em>&nbsp;types and collects telemetry about outgoing HTTP requests.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Instrumentation.SqlClient<\/strong><\/em>&nbsp;instruments the&nbsp;<em>Microsoft.Data.SqlClient<\/em>&nbsp;and&nbsp;<em>System.Data.SqlClient<\/em>&nbsp;types and collects telemetry about database operations.<\/li><li>The&nbsp;<em><strong>OpenTelemetry.Instrumentation.StackExchangeRedis<\/strong><\/em>&nbsp;instruments the&nbsp;<em>StackExchange.Redis<\/em>&nbsp;type and collects telemetry about outgoing calls to Redis.<\/li><\/ul><\/li><\/ul>\n\n\n\n<p>In the near future I expect to see more and more instrumentation libraries like these ones so we can instrument the most common dependencies with no effort at all, just install a nuget, add some config lines in the&nbsp;<em>Startup<\/em>&nbsp;and you\u2019re good to go.<\/p>\n\n\n\n<h1 id=\"adding-opentelemetry-on-app1\">Adding OpenTelemetry on App1<\/h1>\n\n\n\n<p><strong>1 . Setup the OpenTelemetry library<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>services.AddOpenTelemetryTracing(builder =&gt;\n{\n    builder.AddAspNetCoreInstrumentation()\n        .AddHttpClientInstrumentation()\n        .AddSource(nameof(PublishMessageController))\n        .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(\"App1\"))\n        .AddJaegerExporter(opts =&gt;\n        {\n            opts.AgentHost = Configuration&#91;\"Jaeger:AgentHost\"];\n            opts.AgentPort = Convert.ToInt32(Configuration&#91;\"Jaeger:AgentPort\"]);\n            opts.ExportProcessorType = ExportProcessorType.Simple;\n        });\n});\n<\/code><\/pre>\n\n\n\n<p>This is the first app we\u2019re instrumenting so I\u2019m going to explain a little bit what we\u2019re doing line by line<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>AddAspNetCoreInstrumentation()\n<\/code><\/pre>\n\n\n\n<p>Enables NET Core instrumentation.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>AddHttpClientInstrumentation()\n<\/code><\/pre>\n\n\n\n<p>Enable HTTP Instrumentation.<br>The Api 1 makes an HTTP request to the App2, if we want to trace the HTTP call between these 2 apps we can do it simply by adding this extension method.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.AddSource(nameof(PublishMessageController))\n<\/code><\/pre>\n\n\n\n<p>The&nbsp;<code>AddSource<\/code>&nbsp;method can be used to add a ActivitySource to the provider. Multiple AddSource can be called to add more than one span.<\/p>\n\n\n\n<p>Why we need this? The Api 1 queues a message into a rabbit queue and we want to record this trace.<br>In the former paragraph we have seen that HTTP requests has built-in instrumentation via method extension, that is not the case for the RabbitMQ dependency. In order to continue the distributed transaction, we must create a new Activity.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(\"App1\"))\n<\/code><\/pre>\n\n\n\n<p>A Resource is the immutable representation of the entity producing the telemetry.<br>With the&nbsp;<code>SetResourceBuilder<\/code>&nbsp;method we\u2019re configuring the Resource for the application.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>AddJaegerExporter(opts =&gt;\n{\n    opts.AgentHost = Configuration&#91;\"Jaeger:AgentHost\"];\n    opts.AgentPort = Convert.ToInt32(Configuration&#91;\"Jaeger:AgentPort\"]);\n});\n<\/code><\/pre>\n\n\n\n<p>This method sets Jaeger as the exporter where all the traces are going to be sent.<\/p>\n\n\n\n<p><strong>2 . Instrument dependency calls<\/strong><\/p>\n\n\n\n<p>Unlike the HTTP request, OpenTelemetry does not yet have support for automatic RabbitMq trace correlation.<\/p>\n\n\n\n<p>The code below demonstrates how the&nbsp;<em>\u201cpublish message\u201d<\/em>&nbsp;trace can be created. The code snippet adds the trace information to the enqueued message header, which will later be used to link both operations.<\/p>\n\n\n\n<p>Specifically we are using a Propagator to inject the activity into the message header that is going to be queued to Rabbit, afterwards the consumer application will use another Propagator to extract the Activity and link the producer activity with the consumer activity.<\/p>\n\n\n\n<p>Also we are also using the Tags attribute to store relevant metadata into the Activity.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;ApiController]\n&#91;Route(\"publish-message\")]\npublic class PublishMessageController : ControllerBase\n{\n    private static readonly ActivitySource Activity = new(nameof(PublishMessageController));\n    private static readonly TextMapPropagator Propagator = Propagators.DefaultTextMapPropagator;\n\n    private readonly ILogger&lt;PublishMessageController&gt; _logger;\n    private readonly IConfiguration _configuration;\n\n    public PublishMessageController(\n        ILogger&lt;PublishMessageController&gt; logger,\n        IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n    }\n\n    &#91;HttpGet]\n    public void Get()\n    {\n        try\n        {\n            using (var activity = Activity.StartActivity(\"RabbitMq Publish\", ActivityKind.Producer))\n            {\n                var factory = new ConnectionFactory { HostName = _configuration&#91;\"RabbitMq:Host\"] };\n                using (var connection = factory.CreateConnection())\n                using (var channel = connection.CreateModel())\n                {\n                    var props = channel.CreateBasicProperties();\n\n                    AddActivityToHeader(activity, props);\n\n                    channel.QueueDeclare(queue: \"sample\",\n                        durable: false,\n                        exclusive: false,\n                        autoDelete: false,\n                        arguments: null);\n\n                    var body = Encoding.UTF8.GetBytes(\"I am app1\");\n\n                    channel.BasicPublish(exchange: \"\",\n                        routingKey: \"sample\",\n                        basicProperties: props,\n                        body: body);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            _logger.LogError(\"Error trying to publish a message\", e);\n            throw;\n        }\n    }\n\n    private void AddActivityToHeader(Activity activity, IBasicProperties props)\n    {\n        Propagator.Inject(new PropagationContext(activity.Context, Baggage.Current), props, InjectContextIntoHeader);\n        activity?.SetTag(\"messaging.system\", \"rabbitmq\");\n        activity?.SetTag(\"messaging.destination_kind\", \"queue\");\n        activity?.SetTag(\"messaging.rabbitmq.queue\", \"sample\");\n    }\n\n    private void InjectContextIntoHeader(IBasicProperties props, string key, string value)\n    {\n        try\n        {\n            props.Headers ??= new Dictionary&lt;string, object&gt;();\n            props.Headers&#91;key] = value;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to inject trace context.\");\n        }\n    }\n}\n<\/code><\/pre>\n\n\n\n<h1 id=\"adding-opentelemetry-on-app2\">Adding OpenTelemetry on App2<\/h1>\n\n\n\n<p><strong>1 . Setup the OpenTelemetry library<\/strong><\/p>\n\n\n\n<p>The App2 is a console app so we have to setup the library in a different way, instead of using an IServiceCollection extension we\u2019re creating directly a TraceProvider. Apart from that the setup looks pretty much the same.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code> Sdk.CreateTracerProviderBuilder()\n    .AddHttpClientInstrumentation()\n    .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(\"App2\"))\n    .AddSource(nameof(Program))\n    .AddJaegerExporter(opts =&gt;\n    {\n        opts.AgentHost = _configuration&#91;\"Jaeger:AgentHost\"];\n        opts.AgentPort = Convert.ToInt32(_configuration&#91;\"Jaeger:AgentPort\"]);\n    })\n    .Build();\n<\/code><\/pre>\n\n\n\n<p><strong>2 . Instrument dependency calls<\/strong><\/p>\n\n\n\n<p>The HTTP call is being instrumented automatically thanks to the&nbsp;<code>AddHttpClientInstrumentation<\/code>&nbsp;extension method, but this app also dequeues a message from Rabbit, so we want to instrument that part.<br>The code is pretty much the same as the one we have created for the Rabbit producer on App1, the only difference is that instead of injecting the activity we are to extracting it from the message header.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>private static async Task ProcessMessage(BasicDeliverEventArgs ea,\n            HttpClient httpClient,\n            IModel rabbitMqChannel)\n{\n    try\n    {\n      \/\/Extract the activity and set it into the current one\n      var parentContext = Propagator.Extract(default, ea.BasicProperties, ExtractTraceContextFromBasicProperties);\n      Baggage.Current = parentContext.Baggage;\n\n      \/\/Start a new Activity\n      using (var activity = Activity.StartActivity(\"Process Message\", ActivityKind.Consumer, parentContext.ActivityContext))\n      {\n\n          var body = ea.Body.ToArray();\n          var message = Encoding.UTF8.GetString(body);\n\n          \/\/Add Tags to the Activity\n          AddActivityTags(activity);\n\n          _logger.LogInformation(\"Message Received: \" + message);\n\n          _ = await httpClient.PostAsync(\"\/sql-to-event\",\n              new StringContent(JsonSerializer.Serialize(message),\n                  Encoding.UTF8,\n                  \"application\/json\"));\n\n          rabbitMqChannel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);\n      }\n\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError($\"There was an error processing the message: {ex} \");\n    }\n}\n\n\/\/Extract the Activity from the message header\nprivate static IEnumerable&lt;string&gt; ExtractTraceContextFromBasicProperties(IBasicProperties props, string key)\n{\n    try\n    {\n        if (props.Headers.TryGetValue(key, out var value))\n        {\n            var bytes = value as byte&#91;];\n            return new&#91;] { Encoding.UTF8.GetString(bytes) };\n        }\n    }\n    catch (Exception ex)\n    {\n        _logger.LogError($\"Failed to extract trace context: {ex}\");\n    }\n\n    return Enumerable.Empty&lt;string&gt;();\n}\n\n\/\/Add Tags to the Activity\nprivate static void AddActivityTags(Activity activity)\n{\n    activity?.SetTag(\"messaging.system\", \"rabbitmq\");\n    activity?.SetTag(\"messaging.destination_kind\", \"queue\");\n    activity?.SetTag(\"messaging.rabbitmq.queue\", \"sample\");\n}\n<\/code><\/pre>\n\n\n\n<h1 id=\"adding-opentelemetry-on-app3\">Adding OpenTelemetry on App3<\/h1>\n\n\n\n<p><strong>1 . Setup the OpenTelemetry library<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>services.AddOpenTelemetryTracing(builder =&gt;\n{\n    builder.AddAspNetCoreInstrumentation()\n        .AddSource(nameof(RabbitRepository))\n        .AddSqlClientInstrumentation()\n        .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(\"App3\"))\n        .AddJaegerExporter(opts =&gt;\n        {\n            opts.AgentHost = Configuration&#91;\"Jaeger:AgentHost\"];\n            opts.AgentPort = Convert.ToInt32(Configuration&#91;\"Jaeger:AgentPort\"]);\n        });\n});\n<\/code><\/pre>\n\n\n\n<p>The setup looks almost identical as the ones on the App1 and App2. There is only one thing worth mentioning here:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>AddSqlClientInstrumentation()\n<\/code><\/pre>\n\n\n\n<p>This app is not making any HTTP request, instead of that is querying a database, so we\u2019re using the SQL extension method to enable SQL instrumentation. We\u2019re simply swapping the&nbsp;<code>OpenTelemetry.Instrumentation.Http<\/code>&nbsp;library for the&nbsp;<code>OpenTelemetry.Instrumentation.SqlClient<\/code>&nbsp;library.<\/p>\n\n\n\n<p>This app is also queuing a message into a RabbitMq queue, but the code it\u2019s exactly the same as the one I have showed for the app1 section.<\/p>\n\n\n\n<h2 id=\"adding-opentelemetry-on-app4\">Adding OpenTelemetry on App4<\/h2>\n\n\n\n<p><strong>1 . Setup the OpenTelemetry library<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>services.AddOpenTelemetryTracing(builder =&gt;\n{\n    var provider = services.BuildServiceProvider();\n    IConfiguration config = provider\n            .GetRequiredService&lt;IConfiguration&gt;();\n\n    builder.AddAspNetCoreInstrumentation()\n        .AddHttpClientInstrumentation()\n        .Configure((sp, builder) =&gt;\n          {\n              RedisCache cache = (RedisCache)sp.GetRequiredService&lt;IDistributedCache&gt;();\n              builder.AddRedisInstrumentation(cache.GetConnection());\n          })\n        .AddSource(nameof(Worker))\n        .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(\"App4\"))\n        .AddJaegerExporter(opts =&gt;\n        {                    \n            \n            opts.AgentHost = config&#91;\"Jaeger:AgentHost\"];\n            opts.AgentPort = Convert.ToInt32(config&#91;\"Jaeger:AgentPort\"]);\n            opts.ExportProcessorType = ExportProcessorType.Simple;\n        });\n});\n<\/code><\/pre>\n\n\n\n<p>This app dequeues a message from a RabbitMq queue and stores the message content into a Redis cache database.<\/p>\n\n\n\n<p>The instrumentation part for dequeuing the message from RabbitMq looks exactly the same as the snippet I have put on the App2 section, so I\u2019m going to skip that part.<\/p>\n\n\n\n<p>The instrumentation for Redis is a little more problematic.<br>The issue when trying to instrument Redis is that the&nbsp;<code>AddRedisInstrumentation()<\/code>&nbsp;extension method needs an instance of the Redis&nbsp;<code>ConnectionMultiplexer<\/code>.<br>If you\u2019re using an&nbsp;<code>IDistributedCache<\/code>&nbsp;interface and the&nbsp;<code>AddStackExchangeRedisCache<\/code>&nbsp;extension method to configure the Redis connection, like this one:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>services.AddStackExchangeRedisCache(options =&gt;\n{\n    var connString =\n        $\"{hostContext.Configuration&#91;\"Redis:Host\"]}:{hostContext.Configuration&#91;\"Redis:Port\"]}\";\n    options.Configuration = connString;\n});\n<\/code><\/pre>\n\n\n\n<p>You will realize that you can\u2019t access the&nbsp;<code>ConnectionMultiplexer<\/code>&nbsp;property because is not publicly accesible, so I\u2019m writing an extension method that is using Reflection to obtain it.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public static class RedisCacheExtensions\n{\n    public static ConnectionMultiplexer GetConnection(this RedisCache cache)\n    {\n        \/\/ensure connection is established\n        typeof(RedisCache).InvokeMember(\"Connect\", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.InvokeMethod, null, cache, new object&#91;] { });\n\n        \/\/get connection multiplexer\n        var fi = typeof(RedisCache).GetField(\"_connection\", BindingFlags.Instance | BindingFlags.NonPublic);\n        var connection = (ConnectionMultiplexer)fi.GetValue(cache);\n        return connection;\n    }\n}\n<\/code><\/pre>\n\n\n\n<p>Also, as you can see I\u2019m not using directly the&nbsp;<code>AddRedisInstrumentation()<\/code>&nbsp;method, instead of that I\u2019m wrapping the&nbsp;<code>AddRedisInstrumentation()<\/code>&nbsp;methood with the&nbsp;<code>Configure()<\/code>&nbsp;method.<br>The&nbsp;<code>Configure()<\/code>&nbsp;method is an overload method that allows to get a hold of the&nbsp;<code>IServiceProvider<\/code>&nbsp;instance.<\/p>\n\n\n\n<h1 id=\"jaeger\">Jaeger<\/h1>\n\n\n\n<p>After adding the OpenTelemetry library on these 4 apps we are going to generate some traffic and afterwards access Jaeger to start analyzing the traces that the apps are sending.<\/p>\n\n\n\n<p>If we take a look at the entire trace, this is how it looks:<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger.png\" alt=\"otel-jaeger\"\/><\/figure>\n\n\n\n<p>Let me break it up a little bit for you. That\u2019s a zoomed image of the spans we have created in our trace<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-span.png\" alt=\"otel-jaeger-span\"\/><\/figure>\n\n\n\n<ul><li>The first span (publish-message) corresponds to the App1 api endpoint, that span is created automatically when the api controller is executed thanks to the&nbsp;<code>AddAspNetCoreInstrumentation()<\/code>&nbsp;extension method.<\/li><li>The second span (RabbitMq publish) is an Activity that we have created manually on the App1. You can see the code snippet on the \u201cAdding OpenTelemetry on App1\u201d section.<\/li><li>The third span (Process Message) is an Activity that we have created manually on the App2, also you can see the code snippet on the \u201cAdding OpenTelemetry on App2\u201d section.<\/li><li>The fourth span (HTTP POST) corresponds to the HTTP request that the App2 is making to the App3. That span is created automatically thanks to the&nbsp;<code>AddHttpClientInstrumentation()<\/code>&nbsp;extension method found on the App2 setup.<\/li><li>The fifth span (sql-to-event) corresponds to the App3 sql-to-event api endpoint, that span is created automatically when the api controller is executed thanks to the&nbsp;<code>AddAspNetCoreInstrumentation()<\/code>&nbsp;extension method.<\/li><li>The sixth span (sqlserver) corresponds to the SQL query that the App3 is doing, that span is created automatically thanks to the&nbsp;<code>AddSqlClientInstrumentation()<\/code>&nbsp;extension method.<\/li><li>The seventh span (RabbitMq publish) is an Activity that we have created manually on the App3.<\/li><li>The eigth span (Process Message) is an Activity that we have created manually on the App4.<\/li><li>The last 2 spans correspond to the Redis instructions that we are doing on the App4, both spans are created automatically thanks to the&nbsp;<code>AddRedisInstrumentation()<\/code>&nbsp;extension method.<\/li><\/ul>\n\n\n\n<p>If we want more info on any span we can drill-down and inspect the metadata. For example if we inspect the \u201cHTTP POST\u201d span we can see more info about it.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-http-instrumentation.png\" alt=\"otel-jaeger-http-instrumentation\"\/><\/figure>\n\n\n\n<p>Also, do you remember that in the App1 we added some extra Tags on the Activity?<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>activity?.SetTag(\"messaging.system\", \"rabbitmq\");\nactivity?.SetTag(\"messaging.destination_kind\", \"queue\");\nactivity?.SetTag(\"messaging.rabbitmq.queue\", \"sample\");\n<\/code><\/pre>\n\n\n\n<p>Here is the result:<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-rabbit-tags.png\" alt=\"otel-jaeger-rabbit-tags\"\/><\/figure>\n\n\n\n<p>Jaeger is capable of building a dependency-graph after looking at the traces.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-dag.png\" alt=\"otel-jaeger-dag\"\/><\/figure>\n\n\n\n<p>Also is capable of giving performance statistics.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-statistics.png\" alt=\"otel-jaeger-statistics\"\/><\/figure>\n\n\n\n<p>And compare traces.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https:\/\/www.mytechramblings.com\/img\/otel-jaeger-compare-traces.png\" alt=\"otel-jaeger-compare-traces\"\/><\/figure>\n\n\n\n<h1 id=\"how-to-test-the-example-apps\">How to test the example apps<\/h1>\n\n\n\n<p>If you want to take a look at the 4 apps, I have uploaded everything on my&nbsp;<a href=\"https:\/\/github.com\/vinaykarora\/opentelemetry-tracing-demo\">GitHub repository<\/a><\/p>\n\n\n\n<p>If you want to try for yourselves to execute this example, I have uploaded also a&nbsp;<strong>docker-compose<\/strong>&nbsp;file with everything you need, so you can run a compose up and you\u2019re good to go.<\/p>\n\n\n\n<p>But there is little caveat I wanted to mention in the docker-compose file.<\/p>\n\n\n\n<p>With docker-compose you can control the order of the services startup and shutdown with the depends_on option, but it does not wait until a container is \u201cready\u201d, it only waits until is running.<\/p>\n\n\n\n<p>In my case that\u2019s a problem because App2 and App4 need to wait for the rabbitMq container to be ready, to avoid this problem the compose file is overwriting the \u201centrypoint\u201d for both apps and executing a shell script that makes both apps sleep 30 seconds before starting up.<\/p>\n\n\n\n<p>Here\u2019s the docker-compose file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>version: '3.4'\n\nnetworks:\n  tracing:\n    name: tracing-network\n    \nservices:\n  rabbitmq:\n    image: rabbitmq:3.6.15-management\n    ports:\n      - 15672:15672\n      - 5672\n    networks:\n      - tracing\n\n  sqlserver:\n    image: mcr.microsoft.com\/mssql\/server:2019-GA-ubuntu-16.04\n    environment:\n      - ACCEPT_EULA=Y\n      - SA_PASSWORD=Pass@Word1\n    ports:\n      - 1433\n    networks:\n      - tracing\n\n  redis:\n    image: redis:6.2.1\n    ports:\n    - 6379:6379\n    networks:\n      - tracing\n    \n  jaeger:\n    image: jaegertracing\/all-in-one\n    container_name: jaeger\n    restart: unless-stopped\n    ports:\n      - 5775:5775\/udp\n      - 5778:5778\n      - 6831:6831\/udp\n      - 6832:6832\/udp\n      - 9411:9411\n      - 14268:14268\n      - 16686:16686\n    networks:\n      - tracing\n\n  app1:\n    build:\n      context: .\/App1.WebApi\n    ports:\n      - \"5000:80\"\n    networks:\n      - tracing\n    depends_on: \n      - rabbitmq\n      - jaeger\n      - app3\n    environment:\n      Jaeger__AgentHost: jaeger\n      Jaeger__AgentPort: 6831\n      RabbitMq__Host: rabbitmq\n      App3Endpoint: http:\/\/app3\/dummy\n\n  app2:\n    stdin_open: <strong>true<\/strong>\n    tty: <strong>true<\/strong>\n    build:\n      context: .\/App2.RabbitConsumer.Console\n    networks:\n      - tracing\n    depends_on: \n      - rabbitmq\n      - jaeger\n      - app3\n    entrypoint: &#91;\".\/wait.sh\", \"30\", \"dotnet\", \"App2.RabbitConsumer.Console.dll\"]\n    environment:\n      Jaeger__AgentHost: jaeger\n      Jaeger__AgentPort: 6831\n      RabbitMq__Host: rabbitmq\n      App3UriEndpoint: http:\/\/app3\n\n  app3:\n    build:\n      context: .\/App3.WebApi\n    ports:\n      - \"5001:80\"\n    networks:\n      - tracing\n    depends_on: \n      - rabbitmq\n      - jaeger\n      - sqlserver\n    environment:\n      Jaeger__AgentHost: jaeger\n      Jaeger__AgentPort: 6831\n      RabbitMq__Host: rabbitmq\n      SqlDbConnString: server=sqlserver;user id=sa;password=Pass@Word1;\n\n  app4:\n    build:\n      context: .\/App4.RabbitConsumer.HostedService\n    networks:\n      - tracing\n    depends_on: \n      - rabbitmq\n      - jaeger\n      - redis\n    entrypoint: &#91;\".\/wait.sh\", \"30\", \"dotnet\", \"App4.RabbitConsumer.HostedService.dll\"]\n    environment:\n      Jaeger__AgentHost: jaeger\n      Jaeger__AgentPort: 6831\n      RabbitMq__Host: rabbitmq\n      Redis__Host: redis\n      Redis__Port: 6379\n<\/code><\/pre>\n","protected":false},"excerpt":{"rendered":"<p>Just show me the codeAs always if you don\u2019t care about the post I have upload the source code on my&nbsp;Github A few months ago the first stable version of the OpenTelemetry client for dotnet was released and since then I have wanted to write a little bit about it. OpenTelemetry is a set of &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"https:\/\/vinayaroratech.com\/dotnet\/getting-started-with-opentelemetry-and-distributed-tracing-in-net-core\/\"> <span class=\"screen-reader-text\">Getting started with OpenTelemetry and distributed tracing in .NET Core<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[1],"tags":[81,124,123,121,120,122],"_links":{"self":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/946"}],"collection":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/comments?post=946"}],"version-history":[{"count":2,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/946\/revisions"}],"predecessor-version":[{"id":963,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/posts\/946\/revisions\/963"}],"wp:attachment":[{"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/media?parent=946"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/categories?post=946"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/vinayaroratech.com\/wp-json\/wp\/v2\/tags?post=946"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}